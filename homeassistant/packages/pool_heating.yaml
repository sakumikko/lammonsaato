# Pool Heating Package
# Copy this file to /config/packages/pool_heating.yaml
#
# Updated for 15-minute Nordpool intervals with flexible heating blocks:
# - 30-60 minute heating blocks (configurable)
# - Equal duration breaks between blocks
# - Up to 5 hours (300 minutes) of heating per night
# - Supports up to 10 blocks for maximum flexibility
# - Cost constraint: set max EUR per night, cheapest blocks are enabled first
#
# Pool Heating Control:
# - switch.altaan_lammityksen_esto: Heating prevention switch (OFF = allow heating)
# - switch.altaan_kiertovesipumppu: Circulation pump (ON when heating)
#
# CONFIGURATION:
# If your Nordpool sensor has a different entity ID, search and replace:
#   sensor.nordpool_kwh_fi_eur_3_10_0255
# with your actual sensor ID (find it in Developer Tools > States)

# ============================================
# INPUT HELPERS
# ============================================

input_boolean:
  pool_heating_enabled:
    name: "Pool Heating Enabled"
    icon: mdi:pool-thermometer

  # Night session complete flag - set when target temp reached
  pool_heating_night_complete:
    name: "Pool Heating Night Complete"
    icon: mdi:check-circle

  # Individual block enable toggles
  pool_heat_block_1_enabled:
    name: "Block 1 Enabled"
    icon: mdi:checkbox-marked
  pool_heat_block_2_enabled:
    name: "Block 2 Enabled"
    icon: mdi:checkbox-marked
  pool_heat_block_3_enabled:
    name: "Block 3 Enabled"
    icon: mdi:checkbox-marked
  pool_heat_block_4_enabled:
    name: "Block 4 Enabled"
    icon: mdi:checkbox-marked
  pool_heat_block_5_enabled:
    name: "Block 5 Enabled"
    icon: mdi:checkbox-marked
  pool_heat_block_6_enabled:
    name: "Block 6 Enabled"
    icon: mdi:checkbox-marked
  pool_heat_block_7_enabled:
    name: "Block 7 Enabled"
    icon: mdi:checkbox-marked
  pool_heat_block_8_enabled:
    name: "Block 8 Enabled"
    icon: mdi:checkbox-marked
  pool_heat_block_9_enabled:
    name: "Block 9 Enabled"
    icon: mdi:checkbox-marked
  pool_heat_block_10_enabled:
    name: "Block 10 Enabled"
    icon: mdi:checkbox-marked

  # Cost-exceeded flags (set by schedule calculation when block exceeds cost limit)
  pool_heat_block_1_cost_exceeded:
    name: "Block 1 Cost Exceeded"
    icon: mdi:currency-eur-off
  pool_heat_block_2_cost_exceeded:
    name: "Block 2 Cost Exceeded"
    icon: mdi:currency-eur-off
  pool_heat_block_3_cost_exceeded:
    name: "Block 3 Cost Exceeded"
    icon: mdi:currency-eur-off
  pool_heat_block_4_cost_exceeded:
    name: "Block 4 Cost Exceeded"
    icon: mdi:currency-eur-off
  pool_heat_block_5_cost_exceeded:
    name: "Block 5 Cost Exceeded"
    icon: mdi:currency-eur-off
  pool_heat_block_6_cost_exceeded:
    name: "Block 6 Cost Exceeded"
    icon: mdi:currency-eur-off
  pool_heat_block_7_cost_exceeded:
    name: "Block 7 Cost Exceeded"
    icon: mdi:currency-eur-off
  pool_heat_block_8_cost_exceeded:
    name: "Block 8 Cost Exceeded"
    icon: mdi:currency-eur-off
  pool_heat_block_9_cost_exceeded:
    name: "Block 9 Cost Exceeded"
    icon: mdi:currency-eur-off
  pool_heat_block_10_cost_exceeded:
    name: "Block 10 Cost Exceeded"
    icon: mdi:currency-eur-off

  # Cost limit applied flag (set when cost limit caused blocks to be disabled)
  pool_heating_cost_limit_applied:
    name: "Cost Limit Applied"
    icon: mdi:alert-circle-outline

input_datetime:
  # Block 1 - Start and End times
  pool_heat_block_1_start:
    name: "Block 1 Start"
    has_date: true
    has_time: true
    icon: mdi:clock-start
  pool_heat_block_1_end:
    name: "Block 1 End"
    has_date: true
    has_time: true
    icon: mdi:clock-end

  # Block 2 - Start and End times
  pool_heat_block_2_start:
    name: "Block 2 Start"
    has_date: true
    has_time: true
    icon: mdi:clock-start
  pool_heat_block_2_end:
    name: "Block 2 End"
    has_date: true
    has_time: true
    icon: mdi:clock-end

  # Block 3 - Start and End times
  pool_heat_block_3_start:
    name: "Block 3 Start"
    has_date: true
    has_time: true
    icon: mdi:clock-start
  pool_heat_block_3_end:
    name: "Block 3 End"
    has_date: true
    has_time: true
    icon: mdi:clock-end

  # Block 4 - Start and End times
  pool_heat_block_4_start:
    name: "Block 4 Start"
    has_date: true
    has_time: true
    icon: mdi:clock-start
  pool_heat_block_4_end:
    name: "Block 4 End"
    has_date: true
    has_time: true
    icon: mdi:clock-end

  # Block 5 - Start and End times
  pool_heat_block_5_start:
    name: "Block 5 Start"
    has_date: true
    has_time: true
    icon: mdi:clock-start
  pool_heat_block_5_end:
    name: "Block 5 End"
    has_date: true
    has_time: true
    icon: mdi:clock-end

  # Block 6 - Start and End times
  pool_heat_block_6_start:
    name: "Block 6 Start"
    has_date: true
    has_time: true
    icon: mdi:clock-start
  pool_heat_block_6_end:
    name: "Block 6 End"
    has_date: true
    has_time: true
    icon: mdi:clock-end

  # Block 7 - Start and End times
  pool_heat_block_7_start:
    name: "Block 7 Start"
    has_date: true
    has_time: true
    icon: mdi:clock-start
  pool_heat_block_7_end:
    name: "Block 7 End"
    has_date: true
    has_time: true
    icon: mdi:clock-end

  # Block 8 - Start and End times
  pool_heat_block_8_start:
    name: "Block 8 Start"
    has_date: true
    has_time: true
    icon: mdi:clock-start
  pool_heat_block_8_end:
    name: "Block 8 End"
    has_date: true
    has_time: true
    icon: mdi:clock-end

  # Block 9 - Start and End times
  pool_heat_block_9_start:
    name: "Block 9 Start"
    has_date: true
    has_time: true
    icon: mdi:clock-start
  pool_heat_block_9_end:
    name: "Block 9 End"
    has_date: true
    has_time: true
    icon: mdi:clock-end

  # Block 10 - Start and End times
  pool_heat_block_10_start:
    name: "Block 10 Start"
    has_date: true
    has_time: true
    icon: mdi:clock-start
  pool_heat_block_10_end:
    name: "Block 10 End"
    has_date: true
    has_time: true
    icon: mdi:clock-end

  # Thermal calibration timestamps
  pool_last_calibration_time:
    name: "Last Thermal Calibration"
    has_date: true
    has_time: true
    icon: mdi:thermometer-check

input_number:
  pool_heat_block_1_price:
    name: "Block 1 Price"
    min: -50
    max: 500
    step: 0.01
    unit_of_measurement: "c/kWh"
    icon: mdi:currency-eur
  pool_heat_block_2_price:
    name: "Block 2 Price"
    min: -50
    max: 500
    step: 0.01
    unit_of_measurement: "c/kWh"
    icon: mdi:currency-eur
  pool_heat_block_3_price:
    name: "Block 3 Price"
    min: -50
    max: 500
    step: 0.01
    unit_of_measurement: "c/kWh"
    icon: mdi:currency-eur
  pool_heat_block_4_price:
    name: "Block 4 Price"
    min: -50
    max: 500
    step: 0.01
    unit_of_measurement: "c/kWh"
    icon: mdi:currency-eur
  pool_heat_block_5_price:
    name: "Block 5 Price"
    min: -50
    max: 500
    step: 0.01
    unit_of_measurement: "c/kWh"
    icon: mdi:currency-eur
  pool_heat_block_6_price:
    name: "Block 6 Price"
    min: -50
    max: 500
    step: 0.01
    unit_of_measurement: "c/kWh"
    icon: mdi:currency-eur
  pool_heat_block_7_price:
    name: "Block 7 Price"
    min: -50
    max: 500
    step: 0.01
    unit_of_measurement: "c/kWh"
    icon: mdi:currency-eur
  pool_heat_block_8_price:
    name: "Block 8 Price"
    min: -50
    max: 500
    step: 0.01
    unit_of_measurement: "c/kWh"
    icon: mdi:currency-eur
  pool_heat_block_9_price:
    name: "Block 9 Price"
    min: -50
    max: 500
    step: 0.01
    unit_of_measurement: "c/kWh"
    icon: mdi:currency-eur
  pool_heat_block_10_price:
    name: "Block 10 Price"
    min: -50
    max: 500
    step: 0.01
    unit_of_measurement: "c/kWh"
    icon: mdi:currency-eur

  # Cost per block (EUR) - calculated based on duration and price
  pool_heat_block_1_cost:
    name: "Block 1 Cost"
    min: 0
    max: 10
    step: 0.001
    unit_of_measurement: "€"
    icon: mdi:currency-eur
  pool_heat_block_2_cost:
    name: "Block 2 Cost"
    min: 0
    max: 10
    step: 0.001
    unit_of_measurement: "€"
    icon: mdi:currency-eur
  pool_heat_block_3_cost:
    name: "Block 3 Cost"
    min: 0
    max: 10
    step: 0.001
    unit_of_measurement: "€"
    icon: mdi:currency-eur
  pool_heat_block_4_cost:
    name: "Block 4 Cost"
    min: 0
    max: 10
    step: 0.001
    unit_of_measurement: "€"
    icon: mdi:currency-eur
  pool_heat_block_5_cost:
    name: "Block 5 Cost"
    min: 0
    max: 10
    step: 0.001
    unit_of_measurement: "€"
    icon: mdi:currency-eur
  pool_heat_block_6_cost:
    name: "Block 6 Cost"
    min: 0
    max: 10
    step: 0.001
    unit_of_measurement: "€"
    icon: mdi:currency-eur
  pool_heat_block_7_cost:
    name: "Block 7 Cost"
    min: 0
    max: 10
    step: 0.001
    unit_of_measurement: "€"
    icon: mdi:currency-eur
  pool_heat_block_8_cost:
    name: "Block 8 Cost"
    min: 0
    max: 10
    step: 0.001
    unit_of_measurement: "€"
    icon: mdi:currency-eur
  pool_heat_block_9_cost:
    name: "Block 9 Cost"
    min: 0
    max: 10
    step: 0.001
    unit_of_measurement: "€"
    icon: mdi:currency-eur
  pool_heat_block_10_cost:
    name: "Block 10 Cost"
    min: 0
    max: 10
    step: 0.001
    unit_of_measurement: "€"
    icon: mdi:currency-eur

  pool_target_temperature:
    name: "Pool Target Temperature"
    min: 20
    max: 35
    step: 0.5
    unit_of_measurement: "°C"
    icon: mdi:thermometer

  # Schedule calculation parameters
  pool_heating_min_block_duration:
    name: "Min Block Duration"
    min: 30
    max: 60
    step: 15
    unit_of_measurement: "min"
    icon: mdi:timer-outline

  pool_heating_max_block_duration:
    name: "Max Block Duration"
    min: 30
    max: 60
    step: 15
    unit_of_measurement: "min"
    icon: mdi:timer

  pool_heating_total_hours:
    name: "Total Heating Hours"
    min: 0
    max: 5
    step: 0.5
    unit_of_measurement: "h"
    icon: mdi:clock-outline

  # Cost constraint: max EUR per night (0 = no limit)
  pool_heating_max_cost_eur:
    name: "Max Cost per Night"
    min: 0
    max: 10
    step: 0.01
    unit_of_measurement: "€"
    icon: mdi:cash-lock

  # Total scheduled cost (sum of enabled blocks)
  pool_heating_total_cost:
    name: "Total Scheduled Cost"
    min: 0
    max: 50
    step: 0.001
    unit_of_measurement: "€"
    icon: mdi:cash-check

  # Thermal calibration - true pool temperatures from circulation readings
  pool_true_temp_pre_heating:
    name: "True Pool Temp (Pre-Heating)"
    min: 10
    max: 40
    step: 0.1
    unit_of_measurement: "°C"
    icon: mdi:thermometer

  pool_true_temp_post_heating:
    name: "True Pool Temp (Post-Heating)"
    min: 10
    max: 40
    step: 0.1
    unit_of_measurement: "°C"
    icon: mdi:thermometer-high

  pool_true_temp_daytime:
    name: "True Pool Temp (Daytime)"
    min: 10
    max: 40
    step: 0.1
    unit_of_measurement: "°C"
    icon: mdi:thermometer-lines

  # Unified true pool temperature - updated at:
  # 1. End of each heating block (circulation just stopped, sensor = true temp)
  # 2. Each calibration event (after 25 min circulation)
  pool_true_temp:
    name: "Pool True Temperature"
    min: 10
    max: 40
    step: 0.01
    unit_of_measurement: "°C"
    icon: mdi:pool-thermometer

input_text:
  pool_heating_schedule_info:
    name: "Schedule Info"
    max: 255
    icon: mdi:information
  pool_heating_schedule_json:
    name: "Schedule JSON"
    max: 255
    icon: mdi:code-json
  pool_heating_night_summary_data:
    name: "Pool Heating Night Summary Data"
    max: 255
    icon: mdi:chart-line

# ============================================
# THERMIA SENSOR MAPPING
# ============================================
#
# This package uses sensors from the thermiagenesis integration.
# NO separate Modbus configuration needed - thermiagenesis handles it.
#
# Actual sensor entity IDs (from your HA installation):
#   - sensor.condenser_out_temperature (hot, going TO pool)
#   - sensor.condenser_in_temperature (cool, coming FROM pool)
#
# Find your sensors in Developer Tools > States > search "condenser" or "thermia"

# ============================================
# TEMPLATE SENSORS
# ============================================

template:
  - sensor:
      # Pool return line temperature (corrected)
      # The raw sensor reports in hundredths of degrees (e.g., 2573 = 25.73°C)
      - name: "Pool Return Line Temperature (corrected)"
        unique_id: pool_return_line_temperature_corrected
        unit_of_measurement: "°C"
        device_class: temperature
        state_class: measurement
        state: >
          {{ states('sensor.pool_return_line_temperature') | float(0) / 100 }}
        availability: >
          {{ states('sensor.pool_return_line_temperature') not in ['unknown', 'unavailable'] }}

      # Temperature difference (delta-T) for energy calculation
      # condenser_out = hot water leaving condenser (going TO pool)
      # condenser_in = cooler water returning to condenser (coming FROM pool)
      # Delta-T = out - in = heat transferred to pool
      - name: "Pool Heat Exchanger Delta T"
        unique_id: pool_heat_exchanger_delta_t
        unit_of_measurement: "°C"
        device_class: temperature
        state: >
          {% set t_out = states('sensor.condenser_out_temperature') | float(0) %}
          {% set t_in = states('sensor.condenser_in_temperature') | float(0) %}
          {{ (t_out - t_in) | round(1) }}
        availability: >
          {{ states('sensor.condenser_out_temperature') not in ['unknown', 'unavailable'] and
             states('sensor.condenser_in_temperature') not in ['unknown', 'unavailable'] }}

      # Thermal power delivered to pool (kW)
      # Formula: Q = flow_rate × ΔT × specific_heat
      # Flow: 45 L/min = 0.75 L/s = 0.00075 m³/s
      # Specific heat of water: 4.186 kJ/(kg·°C)
      # Q (kW) = 0.75 L/s × ΔT × 4.186 / 1000 × 1000 = 0.75 × ΔT × 4.186 / 1000
      # Simplified: Q (kW) = ΔT × 0.75 × 4.186 = ΔT × 3.14
      # NOTE: Only calculates when pool heating is active (not when heating radiators)
      - name: "Pool Thermal Power"
        unique_id: pool_thermal_power
        unit_of_measurement: "kW"
        device_class: power
        state: >
          {% if is_state('binary_sensor.pool_heating_active', 'on') %}
            {% set delta_t = states('sensor.pool_heat_exchanger_delta_t') | float(0) %}
            {% set flow_rate_l_per_s = 45 / 60 %}
            {% set specific_heat = 4.186 %}
            {{ (delta_t * flow_rate_l_per_s * specific_heat) | round(2) }}
          {% else %}
            0
          {% endif %}
        availability: >
          {{ states('sensor.pool_heat_exchanger_delta_t') not in ['unknown', 'unavailable'] and
             states('binary_sensor.pool_heating_active') not in ['unknown', 'unavailable'] }}

      # Electrical power consumption estimate (kW)
      # Based on thermal power and assumed COP of 3
      # Electrical = Thermal / COP
      # NOTE: Only calculates when pool heating is active
      - name: "Pool Heating Electrical Power"
        unique_id: pool_heating_electrical_power
        unit_of_measurement: "kW"
        device_class: power
        state: >
          {% if is_state('binary_sensor.pool_heating_active', 'on') %}
            {% set thermal = states('sensor.pool_thermal_power') | float(0) %}
            {% set cop = 3.0 %}
            {{ (thermal / cop) | round(2) }}
          {% else %}
            0
          {% endif %}
        availability: >
          {{ states('sensor.pool_thermal_power') not in ['unknown', 'unavailable'] }}

      # Current electricity cost rate (EUR/h)
      # Nordpool price is in EUR/kWh
      # NOTE: Only calculates when pool heating is active
      - name: "Pool Heating Cost Rate"
        unique_id: pool_heating_cost_rate
        unit_of_measurement: "€/h"
        state: >
          {% if is_state('binary_sensor.pool_heating_active', 'on') %}
            {% set electrical_kw = states('sensor.pool_heating_electrical_power') | float(0) %}
            {% set price_eur = states('sensor.nordpool_kwh_fi_eur_3_10_0255') | float(0) %}
            {{ (electrical_kw * price_eur) | round(3) }}
          {% else %}
            0
          {% endif %}
        availability: >
          {{ states('sensor.pool_heating_electrical_power') not in ['unknown', 'unavailable'] and
             states('sensor.nordpool_kwh_fi_eur_3_10_0255') not in ['unknown', 'unavailable'] }}

      # Next scheduled heating block
      - name: "Pool Next Heating"
        unique_id: pool_next_heating
        device_class: timestamp
        state: >
          {% set now_ts = now() %}
          {% set ns = namespace(future_blocks=[]) %}
          {% for i in range(1, 11) %}
            {% set block = states('input_datetime.pool_heat_block_' ~ i ~ '_start') %}
            {% if block not in ['unknown', 'unavailable', ''] %}
              {% set block_dt = strptime(block, '%Y-%m-%d %H:%M:%S') | as_local %}
              {% if block_dt > now_ts %}
                {% set ns.future_blocks = ns.future_blocks + [block_dt] %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {% if ns.future_blocks | length > 0 %}
            {{ (ns.future_blocks | sort | first).isoformat() }}
          {% else %}
            unknown
          {% endif %}

      # Current electricity price
      - name: "Current Nordpool Price"
        unique_id: current_nordpool_price
        unit_of_measurement: "c/kWh"
        state: >
          {{ states('sensor.nordpool_kwh_fi_eur_3_10_0255') | float(0) * 100 }}

      # Average price for scheduled heating blocks (only enabled blocks)
      - name: "Pool Heating Average Price"
        unique_id: pool_heating_avg_price
        unit_of_measurement: "c/kWh"
        state: >
          {% set ns = namespace(prices=[]) %}
          {% for i in range(1, 11) %}
            {% if is_state('input_boolean.pool_heat_block_' ~ i ~ '_enabled', 'on') %}
              {% set price = states('input_number.pool_heat_block_' ~ i ~ '_price') | float(0) %}
              {% if price > 0 %}
                {% set ns.prices = ns.prices + [price] %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {% if ns.prices | length > 0 %}
            {{ (ns.prices | sum / ns.prices | length) | round(2) }}
          {% else %}
            0
          {% endif %}

      # Number of scheduled heating blocks (recent and valid)
      - name: "Pool Heating Block Count"
        unique_id: pool_heating_block_count
        state: >
          {% set now_ts = now() %}
          {% set cutoff = now_ts - timedelta(hours=12) %}
          {% set ns = namespace(count=0) %}
          {% for i in range(1, 11) %}
            {% set block = states('input_datetime.pool_heat_block_' ~ i ~ '_start') %}
            {% if block not in ['unknown', 'unavailable', ''] %}
              {% set block_dt = strptime(block, '%Y-%m-%d %H:%M:%S') | as_local %}
              {% if block_dt > cutoff %}
                {% set ns.count = ns.count + 1 %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {{ ns.count }}

      # Count of enabled blocks (blocks that will actually run)
      - name: "Pool Heating Enabled Block Count"
        unique_id: pool_heating_enabled_block_count
        state: >
          {% set now_ts = now() %}
          {% set cutoff = now_ts - timedelta(hours=12) %}
          {% set ns = namespace(count=0) %}
          {% for i in range(1, 11) %}
            {% if is_state('input_boolean.pool_heat_block_' ~ i ~ '_enabled', 'on') %}
              {% set block = states('input_datetime.pool_heat_block_' ~ i ~ '_start') %}
              {% if block not in ['unknown', 'unavailable', ''] %}
                {% set block_dt = strptime(block, '%Y-%m-%d %H:%M:%S') | as_local %}
                {% if block_dt > cutoff %}
                  {% set ns.count = ns.count + 1 %}
                {% endif %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {{ ns.count }}

  - binary_sensor:
      # Is pool currently heating
      # Heating is active when: prevention is OFF AND circulation pump is ON
      - name: "Pool Heating Active"
        unique_id: pool_heating_active
        device_class: running
        state: >
          {{ is_state('switch.altaan_lammityksen_esto', 'off') and
             is_state('switch.altaan_kiertovesipumppu', 'on') }}

      # Are tomorrow's prices available
      - name: "Nordpool Tomorrow Available"
        unique_id: nordpool_tomorrow_available
        state: >
          {{ state_attr('sensor.nordpool_kwh_fi_eur_3_10_0255', 'tomorrow_valid') | default(false) }}

  # 15-minute energy aggregation sensor (aligned with Nordpool pricing periods)
  - trigger:
      - platform: time_pattern
        minutes: "/15"
    sensor:
      - name: "Pool Heating 15min Energy"
        unique_id: pool_heating_15min_energy
        unit_of_measurement: "kWh"
        state_class: measurement
        device_class: energy
        state: >
          {% set current = states('sensor.pool_heating_electricity') | float(0) %}
          {% set last = this.attributes.get('cumulative_at_period_start', current) | float(0) %}
          {{ (current - last) | round(4) }}
        attributes:
          cumulative_at_period_start: "{{ states('sensor.pool_heating_electricity') }}"
          period_start: "{{ now().replace(minute=(now().minute // 15) * 15, second=0, microsecond=0).isoformat() }}"
          period_price_eur: "{{ states('sensor.nordpool_kwh_fi_eur_3_10_0255') | float(0) }}"
          period_cost_eur: >
            {% set current = states('sensor.pool_heating_electricity') | float(0) %}
            {% set last = this.attributes.get('cumulative_at_period_start', current) | float(0) %}
            {% set energy = current - last %}
            {% set price = states('sensor.nordpool_kwh_fi_eur_3_10_0255') | float(0) %}
            {{ (energy * price) | round(4) }}
          heating_date: >
            {% set hour = now().hour %}
            {% if hour < 7 %}
              {{ (now() - timedelta(days=1)).strftime('%Y-%m-%d') }}
            {% elif hour >= 21 %}
              {{ now().strftime('%Y-%m-%d') }}
            {% else %}
              {{ (now() - timedelta(days=1)).strftime('%Y-%m-%d') }}
            {% endif %}

  # Night summary sensor - parses JSON stored in input_text for persistence
  - sensor:
      - name: "Pool Heating Night Summary"
        unique_id: pool_heating_night_summary
        unit_of_measurement: "kWh"
        device_class: energy
        state_class: measurement
        icon: mdi:chart-line
        state: >
          {% set data = states('input_text.pool_heating_night_summary_data') %}
          {% if data and data not in ['unknown', 'unavailable', ''] %}
            {{ (data | from_json).energy | default(0) }}
          {% else %}
            0
          {% endif %}
        attributes:
          heating_date: >
            {% set data = states('input_text.pool_heating_night_summary_data') %}
            {{ (data | from_json).date | default('') if data and data not in ['unknown', 'unavailable', ''] else '' }}
          cost: >
            {% set data = states('input_text.pool_heating_night_summary_data') %}
            {{ (data | from_json).cost | default(0) if data and data not in ['unknown', 'unavailable', ''] else 0 }}
          baseline: >
            {% set data = states('input_text.pool_heating_night_summary_data') %}
            {{ (data | from_json).baseline | default(0) if data and data not in ['unknown', 'unavailable', ''] else 0 }}
          savings: >
            {% set data = states('input_text.pool_heating_night_summary_data') %}
            {{ (data | from_json).savings | default(0) if data and data not in ['unknown', 'unavailable', ''] else 0 }}
          duration: >
            {% set data = states('input_text.pool_heating_night_summary_data') %}
            {{ (data | from_json).duration | default(0) if data and data not in ['unknown', 'unavailable', ''] else 0 }}
          blocks: >
            {% set data = states('input_text.pool_heating_night_summary_data') %}
            {{ (data | from_json).blocks | default(0) if data and data not in ['unknown', 'unavailable', ''] else 0 }}
          outdoor_temp: >
            {% set data = states('input_text.pool_heating_night_summary_data') %}
            {{ (data | from_json).outdoor_avg | default(0) if data and data not in ['unknown', 'unavailable', ''] else 0 }}
          pool_temp: >
            {% set data = states('input_text.pool_heating_night_summary_data') %}
            {{ (data | from_json).pool_final | default(0) if data and data not in ['unknown', 'unavailable', ''] else 0 }}
          avg_price: >
            {% set data = states('input_text.pool_heating_night_summary_data') %}
            {{ (data | from_json).avg_price | default(0) if data and data not in ['unknown', 'unavailable', ''] else 0 }}

  - binary_sensor:
      # Is currently within a scheduled heating block
      - name: "Pool In Heating Window"
        unique_id: pool_in_heating_window
        state: >
          {% set now_ts = now() %}
          {% set ns = namespace(in_block=false) %}
          {% for i in range(1, 11) %}
            {% set start = states('input_datetime.pool_heat_block_' ~ i ~ '_start') %}
            {% set end = states('input_datetime.pool_heat_block_' ~ i ~ '_end') %}
            {% if start not in ['unknown', 'unavailable', ''] and end not in ['unknown', 'unavailable', ''] %}
              {% set start_dt = strptime(start, '%Y-%m-%d %H:%M:%S') | as_local %}
              {% set end_dt = strptime(end, '%Y-%m-%d %H:%M:%S') | as_local %}
              {% if start_dt <= now_ts <= end_dt %}
                {% set ns.in_block = true %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {{ ns.in_block }}

      # Is cost limit currently applied (some blocks disabled due to cost)
      - name: "Pool Heating Cost Limit Active"
        unique_id: pool_heating_cost_limit_active
        device_class: problem
        state: >
          {{ is_state('input_boolean.pool_heating_cost_limit_applied', 'on') }}

# ============================================
# AUTOMATIONS
# ============================================

automation:
  # ----------------------------------------
  # THERMIA INTEGRATION STABILITY
  # ----------------------------------------
  # The thermiagenesis integration has a known bug where polling stops
  # after some idle time. These automations keep it running.

  # Reload Thermia integration hourly to prevent freezing
  - id: thermia_hourly_reload
    alias: "Thermia: Hourly Reload"
    description: "Reload Thermia integration hourly to prevent Modbus freezing"
    trigger:
      - platform: time_pattern
        hours: "/1"  # Every hour
    action:
      - service: homeassistant.reload_config_entry
        data:
          # IMPORTANT: Replace with your Thermia config entry ID
          # Find it in Settings > Devices & Services > Thermia > URL
          entry_id: ac1e4962ee893b58e6d2c1f95e4caeef

  # Reload if Thermia sensors haven't updated in 10 minutes
  # Uses 'for' duration to avoid triggering on momentary connectivity loss
  - id: thermia_stale_recovery
    alias: "Thermia: Stale Sensor Recovery"
    description: "Reload Thermia if sensors stop updating for extended period"
    trigger:
      - platform: template
        value_template: >
          {% set sensor = states.sensor.condenser_out_temperature %}
          {% if sensor is not none and sensor.last_updated is defined %}
            {{ (now() - sensor.last_updated).total_seconds() > 600 }}
          {% else %}
            false
          {% endif %}
        for:
          minutes: 5  # Wait 5 minutes to confirm it's not momentary
    condition:
      # Only reload if the sensor exists but is stale (not if integration is disabled)
      - condition: template
        value_template: >
          {% set sensor = states.sensor.condenser_out_temperature %}
          {{ sensor is not none and sensor.state not in ['unavailable', 'unknown'] }}
    action:
      - service: homeassistant.reload_config_entry
        data:
          entry_id: ac1e4962ee893b58e6d2c1f95e4caeef
        continue_on_error: true
      - service: notify.persistent_notification
        data:
          title: "Thermia Recovered"
          message: "Thermia sensors were stale for >10 min and integration was reloaded at {{ now().strftime('%H:%M') }}"

  # ----------------------------------------
  # POOL HEATING SCHEDULE
  # ----------------------------------------

  # Calculate schedule when tomorrow's prices become available
  - id: pool_calculate_heating_schedule
    alias: "Pool: Calculate Heating Schedule"
    description: "Calculate optimal heating blocks when Nordpool prices available"
    trigger:
      - platform: state
        entity_id: binary_sensor.nordpool_tomorrow_available
        to: "on"
    condition:
      - condition: state
        entity_id: input_boolean.pool_heating_enabled
        state: "on"
    action:
      - service: pyscript.calculate_pool_heating_schedule
      - service: notify.persistent_notification
        data:
          title: "Pool Heating Schedule"
          message: "{{ states('input_text.pool_heating_schedule_info') }}"

  # Stop heating when target temperature is reached
  - id: pool_target_temp_reached
    alias: "Pool: Stop When Target Reached"
    description: "Stop heating and skip remaining blocks when pool reaches target temperature"
    trigger:
      - platform: numeric_state
        entity_id: sensor.pool_return_line_temperature_corrected
        above: input_number.pool_target_temperature
    condition:
      - condition: state
        entity_id: binary_sensor.pool_heating_active
        state: "on"
    action:
      - service: script.pool_heating_block_stop
      - service: input_boolean.turn_on
        target:
          entity_id: input_boolean.pool_heating_night_complete
      - service: notify.persistent_notification
        data:
          title: "Pool Heating Complete"
          message: "Target temperature {{ states('input_number.pool_target_temperature') }}°C reached. Remaining blocks skipped."

  # Start heating at scheduled block times
  - id: pool_start_heating_block_1
    alias: "Pool: Start Heating Block 1"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_1_start
    condition:
      - condition: state
        entity_id: input_boolean.pool_heating_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heat_block_1_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heating_night_complete
        state: "off"
      - condition: template
        value_template: >
          {% set block_start = as_datetime(states('input_datetime.pool_heat_block_1_start')) %}
          {% set block_end = as_datetime(states('input_datetime.pool_heat_block_1_end')) %}
          {{ block_start.date() >= (now() - timedelta(days=1)).date() and block_end > block_start }}
    action:
      - service: script.pool_heating_block_start
        data:
          block_number: 1

  - id: pool_start_heating_block_2
    alias: "Pool: Start Heating Block 2"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_2_start
    condition:
      - condition: state
        entity_id: input_boolean.pool_heating_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heat_block_2_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heating_night_complete
        state: "off"
      - condition: template
        value_template: >
          {% set block_start = as_datetime(states('input_datetime.pool_heat_block_2_start')) %}
          {% set block_end = as_datetime(states('input_datetime.pool_heat_block_2_end')) %}
          {{ block_start.date() >= (now() - timedelta(days=1)).date() and block_end > block_start }}
    action:
      - service: script.pool_heating_block_start
        data:
          block_number: 2

  - id: pool_start_heating_block_3
    alias: "Pool: Start Heating Block 3"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_3_start
    condition:
      - condition: state
        entity_id: input_boolean.pool_heating_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heat_block_3_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heating_night_complete
        state: "off"
      - condition: template
        value_template: >
          {% set block_start = as_datetime(states('input_datetime.pool_heat_block_3_start')) %}
          {% set block_end = as_datetime(states('input_datetime.pool_heat_block_3_end')) %}
          {{ block_start.date() >= (now() - timedelta(days=1)).date() and block_end > block_start }}
    action:
      - service: script.pool_heating_block_start
        data:
          block_number: 3

  - id: pool_start_heating_block_4
    alias: "Pool: Start Heating Block 4"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_4_start
    condition:
      - condition: state
        entity_id: input_boolean.pool_heating_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heat_block_4_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heating_night_complete
        state: "off"
      - condition: template
        value_template: >
          {% set block_start = as_datetime(states('input_datetime.pool_heat_block_4_start')) %}
          {% set block_end = as_datetime(states('input_datetime.pool_heat_block_4_end')) %}
          {{ block_start.date() >= (now() - timedelta(days=1)).date() and block_end > block_start }}
    action:
      - service: script.pool_heating_block_start
        data:
          block_number: 4

  # Stop heating at scheduled block end times
  # Each stop automation checks that the block is valid (end > start) and recent
  - id: pool_stop_heating_block_1
    alias: "Pool: Stop Heating Block 1"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_1_end
    condition:
      - condition: template
        value_template: >
          {% set start = as_datetime(states('input_datetime.pool_heat_block_1_start')) %}
          {% set end = as_datetime(states('input_datetime.pool_heat_block_1_end')) %}
          {{ end > start and end.date() >= (now() - timedelta(days=1)).date() }}
    action:
      - service: script.pool_heating_block_stop

  - id: pool_stop_heating_block_2
    alias: "Pool: Stop Heating Block 2"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_2_end
    condition:
      - condition: template
        value_template: >
          {% set start = as_datetime(states('input_datetime.pool_heat_block_2_start')) %}
          {% set end = as_datetime(states('input_datetime.pool_heat_block_2_end')) %}
          {{ end > start and end.date() >= (now() - timedelta(days=1)).date() }}
    action:
      - service: script.pool_heating_block_stop

  - id: pool_stop_heating_block_3
    alias: "Pool: Stop Heating Block 3"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_3_end
    condition:
      - condition: template
        value_template: >
          {% set start = as_datetime(states('input_datetime.pool_heat_block_3_start')) %}
          {% set end = as_datetime(states('input_datetime.pool_heat_block_3_end')) %}
          {{ end > start and end.date() >= (now() - timedelta(days=1)).date() }}
    action:
      - service: script.pool_heating_block_stop

  - id: pool_stop_heating_block_4
    alias: "Pool: Stop Heating Block 4"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_4_end
    condition:
      - condition: template
        value_template: >
          {% set start = as_datetime(states('input_datetime.pool_heat_block_4_start')) %}
          {% set end = as_datetime(states('input_datetime.pool_heat_block_4_end')) %}
          {{ end > start and end.date() >= (now() - timedelta(days=1)).date() }}
    action:
      - service: script.pool_heating_block_stop

  # Block 5 Start/Stop
  - id: pool_start_heating_block_5
    alias: "Pool: Start Heating Block 5"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_5_start
    condition:
      - condition: state
        entity_id: input_boolean.pool_heating_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heat_block_5_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heating_night_complete
        state: "off"
      - condition: template
        value_template: >
          {% set block_start = as_datetime(states('input_datetime.pool_heat_block_5_start')) %}
          {% set block_end = as_datetime(states('input_datetime.pool_heat_block_5_end')) %}
          {{ block_start.date() >= (now() - timedelta(days=1)).date() and block_end > block_start }}
    action:
      - service: script.pool_heating_block_start
        data:
          block_number: 5

  - id: pool_stop_heating_block_5
    alias: "Pool: Stop Heating Block 5"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_5_end
    condition:
      - condition: template
        value_template: >
          {% set start = as_datetime(states('input_datetime.pool_heat_block_5_start')) %}
          {% set end = as_datetime(states('input_datetime.pool_heat_block_5_end')) %}
          {{ end > start and end.date() >= (now() - timedelta(days=1)).date() }}
    action:
      - service: script.pool_heating_block_stop

  # Block 6 Start/Stop
  - id: pool_start_heating_block_6
    alias: "Pool: Start Heating Block 6"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_6_start
    condition:
      - condition: state
        entity_id: input_boolean.pool_heating_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heat_block_6_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heating_night_complete
        state: "off"
      - condition: template
        value_template: >
          {% set block_start = as_datetime(states('input_datetime.pool_heat_block_6_start')) %}
          {% set block_end = as_datetime(states('input_datetime.pool_heat_block_6_end')) %}
          {{ block_start.date() >= (now() - timedelta(days=1)).date() and block_end > block_start }}
    action:
      - service: script.pool_heating_block_start
        data:
          block_number: 6

  - id: pool_stop_heating_block_6
    alias: "Pool: Stop Heating Block 6"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_6_end
    condition:
      - condition: template
        value_template: >
          {% set start = as_datetime(states('input_datetime.pool_heat_block_6_start')) %}
          {% set end = as_datetime(states('input_datetime.pool_heat_block_6_end')) %}
          {{ end > start and end.date() >= (now() - timedelta(days=1)).date() }}
    action:
      - service: script.pool_heating_block_stop

  # Block 7 Start/Stop
  - id: pool_start_heating_block_7
    alias: "Pool: Start Heating Block 7"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_7_start
    condition:
      - condition: state
        entity_id: input_boolean.pool_heating_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heat_block_7_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heating_night_complete
        state: "off"
      - condition: template
        value_template: >
          {% set block_start = as_datetime(states('input_datetime.pool_heat_block_7_start')) %}
          {% set block_end = as_datetime(states('input_datetime.pool_heat_block_7_end')) %}
          {{ block_start.date() >= (now() - timedelta(days=1)).date() and block_end > block_start }}
    action:
      - service: script.pool_heating_block_start
        data:
          block_number: 7

  - id: pool_stop_heating_block_7
    alias: "Pool: Stop Heating Block 7"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_7_end
    condition:
      - condition: template
        value_template: >
          {% set start = as_datetime(states('input_datetime.pool_heat_block_7_start')) %}
          {% set end = as_datetime(states('input_datetime.pool_heat_block_7_end')) %}
          {{ end > start and end.date() >= (now() - timedelta(days=1)).date() }}
    action:
      - service: script.pool_heating_block_stop

  # Block 8 Start/Stop
  - id: pool_start_heating_block_8
    alias: "Pool: Start Heating Block 8"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_8_start
    condition:
      - condition: state
        entity_id: input_boolean.pool_heating_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heat_block_8_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heating_night_complete
        state: "off"
      - condition: template
        value_template: >
          {% set block_start = as_datetime(states('input_datetime.pool_heat_block_8_start')) %}
          {% set block_end = as_datetime(states('input_datetime.pool_heat_block_8_end')) %}
          {{ block_start.date() >= (now() - timedelta(days=1)).date() and block_end > block_start }}
    action:
      - service: script.pool_heating_block_start
        data:
          block_number: 8

  - id: pool_stop_heating_block_8
    alias: "Pool: Stop Heating Block 8"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_8_end
    condition:
      - condition: template
        value_template: >
          {% set start = as_datetime(states('input_datetime.pool_heat_block_8_start')) %}
          {% set end = as_datetime(states('input_datetime.pool_heat_block_8_end')) %}
          {{ end > start and end.date() >= (now() - timedelta(days=1)).date() }}
    action:
      - service: script.pool_heating_block_stop

  # Block 9 Start/Stop
  - id: pool_start_heating_block_9
    alias: "Pool: Start Heating Block 9"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_9_start
    condition:
      - condition: state
        entity_id: input_boolean.pool_heating_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heat_block_9_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heating_night_complete
        state: "off"
      - condition: template
        value_template: >
          {% set block_start = as_datetime(states('input_datetime.pool_heat_block_9_start')) %}
          {% set block_end = as_datetime(states('input_datetime.pool_heat_block_9_end')) %}
          {{ block_start.date() >= (now() - timedelta(days=1)).date() and block_end > block_start }}
    action:
      - service: script.pool_heating_block_start
        data:
          block_number: 9

  - id: pool_stop_heating_block_9
    alias: "Pool: Stop Heating Block 9"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_9_end
    condition:
      - condition: template
        value_template: >
          {% set start = as_datetime(states('input_datetime.pool_heat_block_9_start')) %}
          {% set end = as_datetime(states('input_datetime.pool_heat_block_9_end')) %}
          {{ end > start and end.date() >= (now() - timedelta(days=1)).date() }}
    action:
      - service: script.pool_heating_block_stop

  # Block 10 Start/Stop
  - id: pool_start_heating_block_10
    alias: "Pool: Start Heating Block 10"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_10_start
    condition:
      - condition: state
        entity_id: input_boolean.pool_heating_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heat_block_10_enabled
        state: "on"
      - condition: state
        entity_id: input_boolean.pool_heating_night_complete
        state: "off"
      - condition: template
        value_template: >
          {% set block_start = as_datetime(states('input_datetime.pool_heat_block_10_start')) %}
          {% set block_end = as_datetime(states('input_datetime.pool_heat_block_10_end')) %}
          {{ block_start.date() >= (now() - timedelta(days=1)).date() and block_end > block_start }}
    action:
      - service: script.pool_heating_block_start
        data:
          block_number: 10

  - id: pool_stop_heating_block_10
    alias: "Pool: Stop Heating Block 10"
    trigger:
      - platform: time
        at: input_datetime.pool_heat_block_10_end
    condition:
      - condition: template
        value_template: >
          {% set start = as_datetime(states('input_datetime.pool_heat_block_10_start')) %}
          {% set end = as_datetime(states('input_datetime.pool_heat_block_10_end')) %}
          {{ end > start and end.date() >= (now() - timedelta(days=1)).date() }}
    action:
      - service: script.pool_heating_block_stop

  # Log temperature data during heating
  # Continues even if Thermia sensors are temporarily unavailable
  - id: pool_log_temperatures
    alias: "Pool: Log Temperatures During Heating"
    trigger:
      - platform: time_pattern
        minutes: "/5"  # Every 5 minutes
    condition:
      - condition: state
        entity_id: binary_sensor.pool_heating_active
        state: "on"
    action:
      - service: pyscript.log_pool_temperatures
        continue_on_error: true  # Don't fail if Thermia sensors unavailable

  # Calculate nightly summary at end of heating window
  - id: pool_night_summary
    alias: "Pool: Calculate Night Summary"
    description: "Calculate summary stats at end of heating window (07:00)"
    trigger:
      - platform: time
        at: "07:00:00"
    action:
      - service: pyscript.calculate_night_summary
        continue_on_error: true

  # ============================================
  # THERMAL CALIBRATION AUTOMATIONS
  # Run circulation to get true pool temperature readings
  # ============================================

  # Pre-heating calibration: 20:30-21:00
  # Run circulation to measure true pool temp before heating starts
  - id: pool_thermal_calibration_pre_heating
    alias: "Pool: Pre-Heating Thermal Calibration"
    description: "Run circulation 30 min before heating to get true pool temp"
    trigger:
      - platform: time
        at: "20:30:00"
    condition:
      - condition: state
        entity_id: input_boolean.pool_heating_enabled
        state: "on"
    action:
      # Start circulation only for calibration (don't touch prevention switch)
      - service: switch.turn_on
        target:
          entity_id: switch.altaan_kiertovesipumppu
      - service: logbook.log
        data:
          name: "Pool Thermal"
          message: "Pre-heating calibration started - circulation only"
      # Wait for sensor to stabilize (25 min)
      - delay:
          minutes: 25
      # Record true temperature
      - service: pyscript.record_true_pool_temp
        data:
          measurement_type: "pre_heating"
        continue_on_error: true
      # Continue circulation for 5 more min
      - delay:
          minutes: 5
      # Stop circulation
      - service: switch.turn_off
        target:
          entity_id: switch.altaan_kiertovesipumppu
      - service: logbook.log
        data:
          name: "Pool Thermal"
          message: "Pre-heating calibration complete"

  # Post-heating calibration: 07:30-08:00
  # Run circulation to measure true pool temp after heating ends
  - id: pool_thermal_calibration_post_heating
    alias: "Pool: Post-Heating Thermal Calibration"
    description: "Run circulation 30 min after heating to get true pool temp"
    trigger:
      - platform: time
        at: "07:30:00"
    action:
      # Start circulation only for calibration (don't touch prevention switch)
      - service: switch.turn_on
        target:
          entity_id: switch.altaan_kiertovesipumppu
      - service: logbook.log
        data:
          name: "Pool Thermal"
          message: "Post-heating calibration started - circulation only"
      # Wait for sensor to stabilize (25 min)
      - delay:
          minutes: 25
      # Record true temperature
      - service: pyscript.record_true_pool_temp
        data:
          measurement_type: "post_heating"
        continue_on_error: true
      # Continue circulation for 5 more min
      - delay:
          minutes: 5
      # Stop circulation
      - service: switch.turn_off
        target:
          entity_id: switch.altaan_kiertovesipumppu
      - service: logbook.log
        data:
          name: "Pool Thermal"
          message: "Post-heating calibration complete"

  # Daytime calibration: 14:00-14:30
  # Run circulation to track cooling curve
  - id: pool_thermal_calibration_daytime
    alias: "Pool: Daytime Thermal Calibration"
    description: "Run circulation at midday to track cooling curve"
    trigger:
      - platform: time
        at: "14:00:00"
    action:
      # Start circulation only for calibration (don't touch prevention switch)
      - service: switch.turn_on
        target:
          entity_id: switch.altaan_kiertovesipumppu
      - service: logbook.log
        data:
          name: "Pool Thermal"
          message: "Daytime calibration started - circulation only"
      # Wait for sensor to stabilize (25 min)
      - delay:
          minutes: 25
      # Record true temperature
      - service: pyscript.record_true_pool_temp
        data:
          measurement_type: "daytime"
        continue_on_error: true
      # Continue circulation for 5 more min
      - delay:
          minutes: 5
      # Stop circulation
      - service: switch.turn_off
        target:
          entity_id: switch.altaan_kiertovesipumppu
      - service: logbook.log
        data:
          name: "Pool Thermal"
          message: "Daytime calibration complete"

  # Periodic update of estimated true temperature
  - id: pool_update_estimated_temp
    alias: "Pool Update Estimated Temperature"
    description: "Update estimated true pool temp every 30 minutes"
    trigger:
      - platform: time_pattern
        minutes: "/30"
    action:
      - service: pyscript.estimate_true_pool_temp
        continue_on_error: true

  # Capture true pool temp at end of heating blocks
  # When heating ends, circulation just stopped and sensor = true pool temp
  - id: pool_capture_true_temp_after_heating
    alias: "Pool: Capture True Temp After Heating"
    description: "Record true pool temp when heating block ends"
    trigger:
      - platform: state
        entity_id: binary_sensor.pool_heating_active
        from: "on"
        to: "off"
    action:
      # Wait a few seconds for sensor reading to stabilize
      - delay:
          seconds: 10
      # Capture the return line temp as true pool temp
      - service: input_number.set_value
        target:
          entity_id: input_number.pool_true_temp
        data:
          value: "{{ states('sensor.pool_return_line_temperature_corrected') | float(0) }}"
      - service: logbook.log
        data:
          name: "Pool Thermal"
          message: "Captured true pool temp after heating: {{ states('sensor.pool_return_line_temperature_corrected') }}°C"

# ============================================
# SCRIPTS
# ============================================

script:
  pool_heating_block_start:
    alias: "Pool Heating Block Start"
    description: "Start a heating block - disables prevention, enables circulation"
    fields:
      block_number:
        description: "Block number (1-10)"
        example: 1
    sequence:
      # Log start - continue even if Thermia unavailable
      - service: pyscript.log_heating_start
        continue_on_error: true
      # Turn OFF the heating prevention switch (allows heat pump to heat pool)
      - service: switch.turn_off
        target:
          entity_id: switch.altaan_lammityksen_esto
      # Turn ON the circulation pump
      - service: switch.turn_on
        target:
          entity_id: switch.altaan_kiertovesipumppu
      - service: logbook.log
        data:
          name: "Pool Heating"
          message: "Block {{ block_number }} started"
          entity_id: binary_sensor.pool_heating_active

  pool_heating_block_stop:
    alias: "Pool Heating Block Stop"
    description: "Stop heating, log energy, run circulation 15min for mixing, then log final temp"
    sequence:
      # Turn ON the heating prevention switch (stops heat pump from heating pool)
      - service: switch.turn_on
        target:
          entity_id: switch.altaan_lammityksen_esto
      # Log session end NOW - captures accurate heating duration and energy
      - service: pyscript.log_heating_end
        continue_on_error: true
      - service: logbook.log
        data:
          name: "Pool Heating"
          message: "Heating stopped, circulation continues for mixing"
          entity_id: binary_sensor.pool_heating_active
      # Keep circulation running for 15 minutes to mix water
      - delay:
          minutes: 15
      # Turn OFF the circulation pump
      - service: switch.turn_off
        target:
          entity_id: switch.altaan_kiertovesipumppu
      # Update final pool temp AFTER mixing
      - service: pyscript.log_session_final_temp
        continue_on_error: true
      - service: logbook.log
        data:
          name: "Pool Heating"
          message: "Block stopped, final pool temp logged after mixing"
          entity_id: binary_sensor.pool_heating_active

  pool_heating_stop:
    alias: "Pool Heating Emergency Stop"
    description: "Emergency stop - immediately prevents heating"
    sequence:
      # Turn ON the heating prevention switch (stops heating)
      - service: switch.turn_on
        target:
          entity_id: switch.altaan_lammityksen_esto
      # Turn OFF the circulation pump
      - service: switch.turn_off
        target:
          entity_id: switch.altaan_kiertovesipumppu
      # Log end - continue even if Thermia unavailable
      - service: pyscript.log_heating_end
        continue_on_error: true

  pool_heating_manual_start:
    alias: "Pool Heating Manual Start (30 min)"
    description: "Manual 30-minute heating session with logging and 15-min mixing"
    sequence:
      # Log start
      - service: pyscript.log_heating_start
        continue_on_error: true
      # Start heating
      - service: switch.turn_off
        target:
          entity_id: switch.altaan_lammityksen_esto
      - service: switch.turn_on
        target:
          entity_id: switch.altaan_kiertovesipumppu
      - service: logbook.log
        data:
          name: "Pool Heating"
          message: "Manual 30-min session started"
          entity_id: binary_sensor.pool_heating_active
      - delay:
          minutes: 30
      # Stop heating but keep circulation
      - service: switch.turn_on
        target:
          entity_id: switch.altaan_lammityksen_esto
      # Log session end NOW - captures accurate heating duration and energy
      - service: pyscript.log_heating_end
        continue_on_error: true
      - service: logbook.log
        data:
          name: "Pool Heating"
          message: "Heating stopped, mixing for 15 min"
          entity_id: binary_sensor.pool_heating_active
      # Mix water for 15 minutes
      - delay:
          minutes: 15
      # Stop circulation
      - service: switch.turn_off
        target:
          entity_id: switch.altaan_kiertovesipumppu
      # Update final pool temp after mixing
      - service: pyscript.log_session_final_temp
        continue_on_error: true
      - service: logbook.log
        data:
          name: "Pool Heating"
          message: "Manual session ended, final temp logged after mixing"
          entity_id: binary_sensor.pool_heating_active

# ============================================
# INTEGRATION SENSORS - Cumulative energy and cost
# ============================================

# Riemann sum integration to convert power (kW) to energy (kWh)
# NOTE: Source is already in kW, so NO unit_prefix needed - integration gives kWh directly
sensor:
  - platform: integration
    source: sensor.pool_heating_electrical_power
    name: "Pool Heating Electricity"
    unique_id: pool_heating_electricity
    unit_time: h
    method: left

  - platform: integration
    source: sensor.pool_heating_cost_rate
    name: "Pool Heating Cumulative Cost"
    unique_id: pool_heating_cumulative_cost
    unit_time: h
    method: left

# ============================================
# UTILITY METERS - Track daily/monthly energy and costs
# ============================================

utility_meter:
  # Daily electricity consumption for pool heating
  # Resets at 20:30, just before heating window starts (21:00-07:00)
  pool_heating_electricity_daily:
    source: sensor.pool_heating_electricity
    name: "Pool Heating Electricity Daily"
    cron: "30 20 * * *"

  # Daily cost for pool heating
  # Resets at 20:30, just before heating window starts
  pool_heating_cost_daily:
    source: sensor.pool_heating_cumulative_cost
    name: "Pool Heating Cost Daily"
    cron: "30 20 * * *"

  # Monthly electricity consumption
  pool_heating_electricity_monthly:
    source: sensor.pool_heating_electricity
    name: "Pool Heating Electricity Monthly"
    cycle: monthly

  # Monthly cost
  pool_heating_cost_monthly:
    source: sensor.pool_heating_cumulative_cost
    name: "Pool Heating Cost Monthly"
    cycle: monthly

# ============================================
# RECORDER - Ensure important data is logged
# ============================================

recorder:
  include:
    entities:
      # Thermia condenser sensors (from thermiagenesis integration)
      - sensor.condenser_out_temperature
      - sensor.condenser_in_temperature
      - sensor.pool_heat_exchanger_delta_t
      # Pool return line (corrected from raw hundredths)
      - sensor.pool_return_line_temperature_corrected
      # Outdoor temperature
      - sensor.outdoor_temperature
      # Energy calculations
      - sensor.pool_thermal_power
      - sensor.pool_heating_electrical_power
      - sensor.pool_heating_cost_rate
      - sensor.pool_heating_electricity
      - sensor.pool_heating_cumulative_cost
      # Utility meters
      - sensor.pool_heating_electricity_daily
      - sensor.pool_heating_cost_daily
      - sensor.pool_heating_electricity_monthly
      - sensor.pool_heating_cost_monthly
      # Analytics entities (15-min, session, nightly)
      - sensor.pool_heating_15min_energy
      - sensor.pool_heating_session
      - sensor.pool_heating_night_summary
      # Nordpool
      - sensor.nordpool_kwh_fi_eur_3_10_0255
      # Pool heating switches
      - switch.altaan_lammityksen_esto
      - switch.altaan_kiertovesipumppu
      - binary_sensor.pool_heating_active
      # Block prices (1-10)
      - input_number.pool_heat_block_1_price
      - input_number.pool_heat_block_2_price
      - input_number.pool_heat_block_3_price
      - input_number.pool_heat_block_4_price
      - input_number.pool_heat_block_5_price
      - input_number.pool_heat_block_6_price
      - input_number.pool_heat_block_7_price
      - input_number.pool_heat_block_8_price
      - input_number.pool_heat_block_9_price
      - input_number.pool_heat_block_10_price
      # Block costs (1-10)
      - input_number.pool_heat_block_1_cost
      - input_number.pool_heat_block_2_cost
      - input_number.pool_heat_block_3_cost
      - input_number.pool_heat_block_4_cost
      - input_number.pool_heat_block_5_cost
      - input_number.pool_heat_block_6_cost
      - input_number.pool_heat_block_7_cost
      - input_number.pool_heat_block_8_cost
      - input_number.pool_heat_block_9_cost
      - input_number.pool_heat_block_10_cost
      # Block schedules (1-10)
      - input_datetime.pool_heat_block_1_start
      - input_datetime.pool_heat_block_1_end
      - input_datetime.pool_heat_block_2_start
      - input_datetime.pool_heat_block_2_end
      - input_datetime.pool_heat_block_3_start
      - input_datetime.pool_heat_block_3_end
      - input_datetime.pool_heat_block_4_start
      - input_datetime.pool_heat_block_4_end
      - input_datetime.pool_heat_block_5_start
      - input_datetime.pool_heat_block_5_end
      - input_datetime.pool_heat_block_6_start
      - input_datetime.pool_heat_block_6_end
      - input_datetime.pool_heat_block_7_start
      - input_datetime.pool_heat_block_7_end
      - input_datetime.pool_heat_block_8_start
      - input_datetime.pool_heat_block_8_end
      - input_datetime.pool_heat_block_9_start
      - input_datetime.pool_heat_block_9_end
      - input_datetime.pool_heat_block_10_start
      - input_datetime.pool_heat_block_10_end
      # Block enable/disable controls (1-10)
      - input_boolean.pool_heating_night_complete
      - input_boolean.pool_heat_block_1_enabled
      - input_boolean.pool_heat_block_2_enabled
      - input_boolean.pool_heat_block_3_enabled
      - input_boolean.pool_heat_block_4_enabled
      - input_boolean.pool_heat_block_5_enabled
      - input_boolean.pool_heat_block_6_enabled
      - input_boolean.pool_heat_block_7_enabled
      - input_boolean.pool_heat_block_8_enabled
      - input_boolean.pool_heat_block_9_enabled
      - input_boolean.pool_heat_block_10_enabled
      # Cost-exceeded flags (1-10)
      - input_boolean.pool_heat_block_1_cost_exceeded
      - input_boolean.pool_heat_block_2_cost_exceeded
      - input_boolean.pool_heat_block_3_cost_exceeded
      - input_boolean.pool_heat_block_4_cost_exceeded
      - input_boolean.pool_heat_block_5_cost_exceeded
      - input_boolean.pool_heat_block_6_cost_exceeded
      - input_boolean.pool_heat_block_7_cost_exceeded
      - input_boolean.pool_heat_block_8_cost_exceeded
      - input_boolean.pool_heat_block_9_cost_exceeded
      - input_boolean.pool_heat_block_10_cost_exceeded
      # Cost constraint
      - input_boolean.pool_heating_cost_limit_applied
      - input_number.pool_heating_max_cost_eur
      - input_number.pool_heating_total_cost
      - binary_sensor.pool_heating_cost_limit_active
      - sensor.pool_heating_enabled_block_count
      # Thermal calibration
      - input_number.pool_true_temp_pre_heating
      - input_number.pool_true_temp_post_heating
      - input_number.pool_true_temp_daytime
      - input_datetime.pool_last_calibration_time
      - sensor.pool_estimated_true_temp
      - sensor.pool_predicted_temp_after_heating
